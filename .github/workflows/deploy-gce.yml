name: Deploy to GCE

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches:
      - main

env:
  REGISTRY_HOST: ${{ vars.REGISTRY_HOST }}
  GCP_PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  GAR_REPOSITORY: ${{ vars.GAR_REPOSITORY }}
  # Optional. If set, deploy will run as this OS user on the VM (avoids defaulting to "runner").
  GCE_SSH_USER: ${{ vars.GCE_SSH_USER }}
  # Optional. Absolute path recommended, e.g. /opt/auto-refactor-agent
  GCE_APP_DIR: ${{ vars.GCE_APP_DIR }}
  # Prevent gcloud from prompting (important because we use heredoc stdin for the remote script).
  CLOUDSDK_CORE_DISABLE_PROMPTS: "1"

jobs:
  deploy:
    name: Deploy to GCE
    runs-on: ubuntu-latest
    # Âè™Âú® CI/CD Pipeline ÊàêÂäü‰∏îÊòØ push to main Êàñ manual dispatch ÊôÇÂü∑Ë°å
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.event == 'push')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment variables
        run: |
          echo "IMAGE_TAG=${GITHUB_SHA::7}" >> $GITHUB_ENV
          echo "GCE_INSTANCE=${{ vars.GCE_INSTANCE }}" >> $GITHUB_ENV
          echo "GCE_ZONE=${{ vars.GCE_ZONE }}" >> $GITHUB_ENV
          echo "GCE_SSH_USER=${{ vars.GCE_SSH_USER }}" >> $GITHUB_ENV
          echo "GCE_APP_DIR=${{ vars.GCE_APP_DIR }}" >> $GITHUB_ENV

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup gcloud CLI
        uses: google-github-actions/setup-gcloud@v2

      - name: Prepare SSH for gcloud (non-interactive)
        run: |
          set -euo pipefail

          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # gcloud compute ssh defaults to ~/.ssh/google_compute_engine
          if [ ! -f ~/.ssh/google_compute_engine ]; then
            ssh-keygen -t rsa -b 3072 -f ~/.ssh/google_compute_engine -N "" -C "gha-${GITHUB_RUN_ID}"
          fi

          chmod 600 ~/.ssh/google_compute_engine
          chmod 644 ~/.ssh/google_compute_engine.pub

      - name: Deploy to GCE
        run: |
          set -euo pipefail

          echo "============================================"
          echo "üöÄ Deploying to GCE"
          echo "============================================"
          echo "Instance: ${{ env.GCE_INSTANCE }}"
          echo "Zone: ${{ env.GCE_ZONE }}"
          echo "Image Tag: ${{ env.IMAGE_TAG }}"
          echo "============================================"

          SSH_TARGET="${{ env.GCE_INSTANCE }}"
          if [ -n "${GCE_SSH_USER:-}" ]; then
            SSH_TARGET="${GCE_SSH_USER}@${{ env.GCE_INSTANCE }}"
          fi

          # SSH Âà∞ GCE ‰∏¶Âü∑Ë°åÈÉ®ÁΩ≤ËÖ≥Êú¨
          gcloud compute ssh "$SSH_TARGET" \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.GCP_PROJECT_ID }} \
            --quiet \
            --ssh-flag="-o BatchMode=yes" \
            --ssh-flag="-o StrictHostKeyChecking=no" \
            --ssh-flag="-o UserKnownHostsFile=/dev/null" \
            --command="bash -s" << 'ENDSSH'
              set -euo pipefail

              APP_DIR="${{ env.GCE_APP_DIR }}"
              if [ -z "$APP_DIR" ]; then
                APP_DIR="$HOME/auto-refactor-agent"
              fi

              echo "üì¶ Authenticating Docker with GAR..."
              if command -v gcloud >/dev/null 2>&1; then
                gcloud auth configure-docker ${{ env.REGISTRY_HOST }} --quiet
              else
                # No gcloud on the VM. Use the instance service account token from metadata server.
                if ! command -v curl >/dev/null 2>&1; then
                  echo "‚ùå curl is required to fetch metadata token (gcloud not found)"
                  exit 1
                fi
                TOKEN_JSON="$(curl -fsS -H 'Metadata-Flavor: Google' \
                  'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token')"
                # Extract "access_token" without relying on python/jq.
                ACCESS_TOKEN="$(printf '%s' "$TOKEN_JSON" | sed -n 's/.*\"access_token\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/p')"
                if [ -z "$ACCESS_TOKEN" ]; then
                  echo "‚ùå Failed to fetch access token from metadata server"
                  exit 1
                fi
                echo "$ACCESS_TOKEN" | docker login -u oauth2accesstoken --password-stdin "https://${{ env.REGISTRY_HOST }}"
              fi

              echo "üì• Pulling latest images..."
              docker pull ${{ env.REGISTRY_HOST }}/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/refactor-base:${{ env.IMAGE_TAG }}
              docker pull ${{ env.REGISTRY_HOST }}/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/refactor-api:${{ env.IMAGE_TAG }}
              docker pull ${{ env.REGISTRY_HOST }}/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/refactor-frontend:${{ env.IMAGE_TAG }}

              # Tag as latest
              docker tag ${{ env.REGISTRY_HOST }}/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/refactor-base:${{ env.IMAGE_TAG }} refactor-base:latest
              docker tag ${{ env.REGISTRY_HOST }}/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/refactor-api:${{ env.IMAGE_TAG }} refactor-api:latest
              docker tag ${{ env.REGISTRY_HOST }}/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/refactor-frontend:${{ env.IMAGE_TAG }} refactor-frontend:latest

              echo "üîÑ Updating services with docker-compose..."
              mkdir -p "$APP_DIR"
              cd "$APP_DIR"

              compose() {
                if command -v docker-compose >/dev/null 2>&1; then
                  docker-compose "$@"
                  return
                fi
                if docker compose version >/dev/null 2>&1; then
                  docker compose "$@"
                  return
                fi
                # Last resort: run Compose v2 in a container (works even on minimal COS images).
                docker run --rm \
                  -v /var/run/docker.sock:/var/run/docker.sock \
                  -v "$PWD:$PWD" -w "$PWD" \
                  docker/compose:2.27.0 "$@"
              }

              # Ensure workspace host dir exists for volume mount.
              WORKSPACE_HOST_DIR="/var/lib/refactor-workspaces"
              if command -v sudo >/dev/null 2>&1; then
                sudo mkdir -p "$WORKSPACE_HOST_DIR" || mkdir -p "$WORKSPACE_HOST_DIR"
              else
                mkdir -p "$WORKSPACE_HOST_DIR"
              fi

              # Create backend env file on first deploy. Keep it stable across deploys.
              if [ ! -f backend.env ]; then
                JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}"
                if [ -z "$JWT_SECRET_KEY" ]; then
                  if command -v openssl >/dev/null 2>&1; then
                    JWT_SECRET_KEY="$(openssl rand -hex 32)"
                  else
                    JWT_SECRET_KEY="$(date +%s%N)"
                  fi
                fi

                cat > backend.env <<EOF
          # Generated by GitHub Actions (first deploy). Edit on VM if needed.
          JWT_SECRET_KEY=$JWT_SECRET_KEY
          ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}

          # Optional: Vertex AI (works best when the VM service account has Vertex permissions)
          GCP_PROJECT_ID=${{ env.GCP_PROJECT_ID }}
          GCP_LOCATION=us-central1
          VERTEX_AI_MODEL=gemini-2.5-pro

          LOG_LEVEL=INFO
          EOF
                chmod 600 backend.env || true
              fi

              # Write compose file on every deploy so it always matches the repo version + current IMAGE_TAG.
              cat > docker-compose.prod.yml <<EOF
          services:
            postgres:
              image: postgres:16
              container_name: refactor-postgres
              ports:
                - "5432:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              environment:
                POSTGRES_USER: langgraph
                POSTGRES_PASSWORD: langgraph_secret
                POSTGRES_DB: langgraph
              networks:
                - refactor-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U langgraph"]
                interval: 10s
                timeout: 5s
                retries: 5

            mongodb:
              image: mongo:7
              container_name: refactor-mongodb
              ports:
                - "27017:27017"
              volumes:
                - mongodb_data:/data/db
              environment:
                MONGO_INITDB_DATABASE: refactor_agent
              networks:
                - refactor-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
                interval: 10s
                timeout: 5s
                retries: 5

            api:
              image: ${{ env.REGISTRY_HOST }}/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/refactor-api:${{ env.IMAGE_TAG }}
              container_name: refactor-api
              ports:
                - "8000:8000"
              volumes:
                - /var/run/docker.sock:/var/run/docker.sock
                - ${WORKSPACE_HOST_DIR}:/tmp/refactor-workspaces
              env_file:
                - ./backend.env
              environment:
                - MONGODB_URL=mongodb://mongodb:27017
                - MONGODB_DATABASE=refactor_agent
                - POSTGRES_URL=postgresql://langgraph:langgraph_secret@postgres:5432/langgraph
                - DEBUG=false
                - DOCKER_BASE_IMAGE=refactor-base:latest
                - DOCKER_VOLUME_PREFIX=/tmp/refactor-workspaces
              depends_on:
                mongodb:
                  condition: service_healthy
                postgres:
                  condition: service_healthy
              networks:
                - refactor-network
              restart: unless-stopped

            frontend:
              image: ${{ env.REGISTRY_HOST }}/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/refactor-frontend:${{ env.IMAGE_TAG }}
              container_name: refactor-frontend
              ports:
                - "80:80"
              depends_on:
                - api
              networks:
                - refactor-network
              restart: unless-stopped

          volumes:
            mongodb_data:
            postgres_data:

          networks:
            refactor-network:
              name: refactor-network
              driver: bridge
          EOF

              # ÂÅúÊ≠¢‰∏¶ÁßªÈô§ËàäÂÆπÂô®
              compose --project-name refactor -f docker-compose.prod.yml down --remove-orphans

              # ÂïüÂãïÊñ∞ÂÆπÂô®
              compose --project-name refactor -f docker-compose.prod.yml up -d

              echo "üßπ Cleaning up old images..."
              docker image prune -f

              echo "‚úÖ Deployment completed successfully!"
          ENDSSH

      - name: Health check
        run: |
          echo "üè• Running health check..."

          # ÂèñÂæó GCE Â§ñÈÉ® IP
          EXTERNAL_IP=$(gcloud compute instances describe ${{ env.GCE_INSTANCE }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.GCP_PROJECT_ID }} \
            --format='get(networkInterfaces[0].accessConfigs[0].natIP)')

          echo "Instance IP: $EXTERNAL_IP"

          # Á≠âÂæÖÊúçÂãôÂïüÂãï
          sleep 30

          # Ê™¢Êü• API ÂÅ•Â∫∑ÁãÄÊÖã
          MAX_RETRIES=10
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f -s "http://${EXTERNAL_IP}:8000/health" > /dev/null; then
              echo "‚úÖ API is healthy!"
              break
            else
              echo "‚è≥ Waiting for API to be ready... ($((RETRY_COUNT + 1))/$MAX_RETRIES)"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              sleep 10
            fi
          done

          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "‚ùå Health check failed after $MAX_RETRIES attempts"
            exit 1
          fi

          # Ê™¢Êü• Frontend
          if curl -f -s "http://${EXTERNAL_IP}:80" > /dev/null; then
            echo "‚úÖ Frontend is accessible!"
          else
            echo "‚ö†Ô∏è Frontend health check failed"
          fi

      - name: Deployment summary
        run: |
          echo "============================================"
          echo "‚úÖ Deployment Summary"
          echo "============================================"
          echo "Instance: ${{ env.GCE_INSTANCE }}"
          echo "Image Tag: ${{ env.IMAGE_TAG }}"
          echo "Deployed Images:"
          echo "  - refactor-base:${{ env.IMAGE_TAG }}"
          echo "  - refactor-api:${{ env.IMAGE_TAG }}"
          echo "  - refactor-frontend:${{ env.IMAGE_TAG }}"
          echo "============================================"

      - name: Notify on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed!"
          echo "Please check the logs and GCE instance status."
